HyPar - Hyperbolic-Parabolic Partial Differential Equations Solver

A finite-difference algorithm to solve hyperbolic-parabolic equations 
of the following form:

    du        d [f_i(u)]         d^2 [g_i(u)]
   ----   +  ------------   =  ---------------- + S(u)  ;   0 < i <= ndims
    dt           dx_i             d (x_i)^2                 (implied summation)

where
  u     -> state vector of size nvar
  f     -> hyperbolic flux function
  g     -> parabolic  function
  S     -> source term
  ndims -> number of space dimensions
  (^ denotes superscript and _ denotes subscript)

The domain, x1_i < x_i < x2_i (where x1_i and x2_i are the upper and 
lower bounds of x_i) is discretized with a Cartesian grid.

- Spatial Discretization of Hyperbolic Terms - Conservative:
  + First order upwind
  + Third order MUSCL with Koren's limiter
  + Fifth order WENO 
  + Fifth order CRWENO
- Spatial Discretization of Parabolic Terms - Conservative and Non-Conservative
  + Second order central
  + Fourth order central (coming soon)
  + Fourth order compact (coming soon)
  + Sixth order compact (coming soon)
  + Sixth order WENO (coming soon)
- Time integration
  + Forward Euler
  + Multi-stage explicit Runge Kutta scheme
    - First, second, third, fourth order schemes
    - SSP RK3
- Physics models
  + Linear advection-diffusion-reaction
  + Fokker-Planck double well
  + Fokker-Planck model for Power Systems
  + Euler equations (1D, 2D, 3D)
  + Porous Medium Equations (Coming soon)
- Output options
  + Plain text
  + Tecplot (2D and 3D problems only)
- Serial as well as parallel (MPI)

The solver provides a standardized template for discretization schemes and 
physical models. New physical models can be easily incorporated by defining 
the following functions for them:-
- Hyperbolic function  
- Parabolic function   
- Source function      
- Upwinding function if hyperbolic function present
- CFL and Diffusion number computation functions
Existing physical models provide a template.
Similarly, new discretization schemes can be added easily by following the 
existing template. The only restriction is that any new discretization scheme
for the hyperbolic terms needs to be conservative (i.e., only the function to
interpolate interface fluxes needs to be specified).

-------------------------------------------------------------------------------------

COMPILING:-

If obtained by cloning the GIT/SVN repository, run these commands:-
> autoreconf -i

This will generate the required files for:
> [CFLAGS="..."] ./configure [--with-mpidir=/path/to/mpi] [--prefix=/install/dir]
> make
> make install

If unpacked from tarball, then proceed with ./configure, make and
make install.

** A serial version can be compiled using the "-Dserial" compile flag.
** If MPI is unavailable or the configure script is unable to detect MPI, then a 
   serial version of the code will get compiled.

-------------------------------------------------------------------------------------

RUNNING:-

> [/path/to/mpi/bin/]mpiexec -n $NPROC /path/to/HyPar_binary

Note: $NPROC needs to be equal to the product of the "iproc" entries in the input
      file "solver.inp".

See section "INPUT FILES" for a list of required input files and their explanations.

-------------------------------------------------------------------------------------

EXAMPLES:-

The folder $(top_srcdir)/Examples contains several examples with all the input files
required to run a case.

-------------------------------------------------------------------------------------

INPUT FILES:-

In general, the following input files are needed by the solver (See also sample input
files in the Examples for a better idea):

- solver.inp - Solver inputs
  ** If any of the keywords listed below is absent, default values will be used.**

  Format:
    begin
      <keyword>   <value> [<value> ... <value>]
      <keyword>   <value> [<value> ... <value>]
      ...
      <keyword>   <value> [<value> ... <value>]
    end

  Keywords:
    ndims               -> number of dimensions
    nvars               -> number of variables per grid point
    size                -> number of grid points in each dimension
    iproc               -> number of processes in each dimension (for MPI runs)
    ghost               -> number of ghost points to use
    n_iter              -> number of time iterations
    time_scheme         -> time-integration scheme ("euler", "rk")
                           (see include/timeintegration.h for a complete list)
    time_scheme_type    -> specific time-integration scheme in case of "rk" 
                           ("1fe","22","33","44","ssprk3")
                           (see include/timeintegration.h for a complete list)
    hyp_space_scheme    -> spatial discretization scheme for hyperbolic terms
                           (see include/interpolation.h for a complete list)
    hyp_interp_type     -> for vector problems, whether to use characteristic-
                           based or component-wise interpolation
                           ("characteristic", "components")
    par_space_type      -> type of discretization for parabolic terms
                           ("conservative-1stage", "nonconservative-1stage")
                           (see include/hypar.h for a complete list)
    par_space_scheme    -> spatial discretization scheme for parabolic terms
                           (see include/interpolation.h for a complete list 
                            for conservative discretization)
                           (see include/secondderivative.h for a complete list 
                            for non-conservative discretization)
    dt                  -> time step size
    screen_op_iter      -> frequency of screen output
    file_op_iter        -> frequency of file output
    write_residual      -> write residual information to file ? (1/0)
    ip_file_type        -> specify whether initial solution file is
                           ASCII text (default) or binary.
    input_mode          -> specify if the initial (and exact) solution is 
                           read in serial (by rank 0) or by all processes.
                           (** see the discussion below on "initial.inp" for
                               more details)
    op_file_format      -> format of output file
                           ("none", "text", "tecplot2d", "tecplot3d")
    op_overwrite        -> Overwrite output file ? ("yes"/"no")
    model               -> Physical model to use
                           ("linear-advection-diffusion-reaction", 
                            "fp-double-well",etc)
                           (see Examples to see currently supported 
                            physical models)
    

- boundary.inp - Boundary inputs

  Format
    <nb>
    <bctype>  <dim> <var> <face> <x1min>  <x1max> [<x2min>  <x2max> ... <x{ndim-1}min>  <x{ndims-1}max>]
    <bctype>  <dim> <var> <face> <x1min>  <x1max> [<x2min>  <x2max> ... <x{ndim-1}min>  <x{ndims-1}max>]
    ...
    <bctype>  <dim> <var> <face> <x1min>  <x1max> [<x2min>  <x2max> ... <x{ndim-1}min>  <x{ndims-1}max>]

  Explanation:
    nb  -> number of boundary conditions
    Followed by nb lines, 1 for each boundary condition, of the format as 
    shown above

    bctype      -> type of boundary condition 
                   ("periodic", "extrapolate", "dirichlet", etc)
                   (see include/boundaryconditions.h for a complete list)
    dim         -> dimension along which to apply this boundary conditions 
                   (0 <= dim < ndims)
    var         -> variable on which to apply this boundary conditions 
                   (0 <= var < nvars)
    face        -> face on which to apply this boundary condition 
                   (1 -> left/xmin; -1 -> right/xmax)

    xNmin, xNmax -> extent of this boundary condition along dimension N
                    note: the values for N=dim are ignored.
                    This needs to be specified for all the dimensions 
                    0 <= N < ndims

- initial.inp / initial_par.inp
  
  The initial solution - The cases in Examples contain codes "init.C" to 
                         generate this input file in the correct format. 
                         They can be modified to generate different initial 
                         conditions (or use different codes as long as it 
                         outputs the initial conditions in the same format 
                         as "init.C")

  If the keyword "ip_file_type" is not specified or specified as "ascii", this
  file needs to be an ASCII file.
  If the keyword "ip_file_type" is specified as "bin" or "binary", this file 
  needs to be a binary file.
  For some examples, the provided "init.C" reads in the value of "ip_file_type"
  and accordingly generates an ASCII or binary file.

  If the keyword "input_mode" is not specified, or specified as "serial", the
  root processor allocates the global domain, reads in the complete initial 
  solution, chops it up and sends it to other ranks.

  If the keyword "input_mode" is specified as "parallel", the code reads in the 
  file "initial_par.inp". This file contains the initial solution divided into
  blocks corresponding to each processor. All the ranks open the file, and read
  in the part containing the initial solution for their part of the domain. Thus
  the global domain is not allocated (useful for memory-limited machines and/or
  big domains). 

  To generate "initial_par.inp", compile and run hypar/Extras/ParallelInput.c 
  after generating "initial.inp" and specifying the number of processors "iproc"
  in solver.inp.
  ** This option is available only for binary initial solution file.

- exact.inp / exact_par.inp (**Optional**)

  The exact solution, if available - used to calculate the numerical errors. 
  The format of this file is same  as that of "initial.inp"

  The above discussion on ASCII/binary files and serial/parallel input modes apply
  to "exact.inp" ("exact_par.inp") as well.

- physics.inp (**optional**)
  
  Format
    begin
      <keyword>     <value>
      <keyword>     <value>
      ...
      <keyword>     <value>
    end

  Physics-specific parameters (eg. advection speed, diffusion coefficient, 
  etc). Keywords are specific to the physical model, so consult an example 
  of a specific physical model to see the required parameters for that model.

- weno.inp (**optional**)
  When using any of the WENO-based schemes (WENO5, CRWENO5, HCWENO5), this file
  specifies the parameters related to calculating the non-linear WENO weights.
  If no present, default values will be used.

  Format
    begin
      <keyword>       <value>
      ...
      <keyword>       <value>
    end

  Keywords
    mapped       (1 or 0)        Use Mapped-WENO weights (Henrick & Aslam, JCP)
    borges       (1 or 0)        Use WENO-Z weights      (Borges, et al, JCP)
    yc           (1 or 0)        Use ESWENO weights      (Yamaleev & Carpenter, JCP)
    no_limiting  (1 or 0)        Use optimal weights (no WENO limiting)
    epsilon      (double)        epsilon parameter in WENO weights
    p            (double)        p parameter in WENO weights
    rc           (double)        rc paramter in hybrid compact WENO scheme (HCWENO5 only)
    xi           (double)        xi paramter in hybrid compact WENO scheme (HCWENO5 only)

- lusolver.inp (**optional**)
  When using compact schemes (for hyperbolic or parabolic discretization), this
  is used to specify the tridiagonal solver related parameters. If not present,
  default values are used.
  For more details: http://www.mcs.anl.gov/~ghosh/codes/tridiaglu.html

  Format
    begin
      <keyword>     <value>
      ...
      <keyword>       <value>
    end

  Keywords
    reducedsolvetype    How to solve the reduced system - gather-and-solve or
                        iteratively
                        ("gather-and-solve", "jacobi)
    evaluate_norm       Evaluate norm every iteration for iterative reduced 
                        system solve (and use norm-based exit criterion)
                        (1 or 0)
                        If 0 (do not evaluate norm, then iterate for maxiter
                        number of iterations)
    maxiter             Maximum number of iterations
    atol                Absolute tolerance
    rtol                Relative tolerance
    verbose             Print iteration and norm to screen (1 or 0)

-------------------------------------------------------------------------------------
